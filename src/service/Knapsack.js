// dp(n, W)表示的是背包剩余容量为W，还有1~n个物品可以选择是，能够取得的最大价值
// 每次只考虑当前选择
// 当还剩i个物品可以选择，背包容量剩余j时，可以分为以下两种情况
// 1.背包无法装下第i个物品，此时只需考虑前面i-1个物品 dp(i,j) = dp(i-1,j)
// 2.背包可以装下第i个物品，考虑是否装入。若不装，和情况1相同，若装入，接下来需要考虑如何在前i-1个物品中选择物品放入容量为j-w[i]的背包中
// -> dp(i,j) = dp(i-1,j-w[i]) + v[i]
// 综合以上情况：
// i = 0 或 j = 0时， dp(i,j) = 0
// j < w[i] 时 dp(i,j) = dp(i-1,j)
// j >= w[i] 时 dp(i,j) = max(dp(i-1,j), dp(i-1,j-w[i]) + v[i])

// 动态规划，存储状态
// i = 0 或 j = 0时， dp[i][j] = 0
// j < w[i] 时 dp[i][j] = dp[i-1][j]
// j >= w[i] 时 dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])

// 空间优化
// dp[i][j]的值只与dp[i-1][j]和dp[i-1][j-w[i]]的值决定，且只与dp[i-1][0...j]的值有关
// 只需存储一个一维dp[0...W]，通过不停更新该数组，最终dp[W]即为结果

// 物品数量为n，背包空间为W时能装入的最大价值
const getValue = (n, W) => {
  // 物体重量w
  const w = [0, 2, 1, 3, 2];
  // 物体价值v
  const v = [0, 3, 2, 4, 2];
  // 物体数量

  // 价值 0 -- W, dp[W]表示这n个物品能被空间为W的背包能装入的最大价值。
  const dp = [0, 0, 0, 0, 0, 0];
  // 为了保证“第i个物品”和数组索引一致，将数组元素右移一位，第一位补0
  for (let i = 1; i <= n; i++) {
    // 由于没有对历史数据备份，从左往右计算会导致结果错误
    for (let j = W; j >= 0; j--) {
      // 物品数量为i，背包剩余空间为j时
      // 如果w[i]
      if (j < w[i]) {
        dp[j] = dp[j];
      } else {
        dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]);
      }
    }
  }
  return dp[W];
};
export default {
  getValue,
};
